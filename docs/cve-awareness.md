# CVE Awareness: Integration Path

This document outlines a phased plan to add CVE awareness to Vectra Guard, with suggested Go modules, data schema, and CLI UX flows.

## Goals

- Provide actionable vulnerability context for dependency installs and execution.
- Reduce unsafe agent decisions by blocking or warning on high-risk packages.
- Preserve auditability with CVE attribution and remediation guidance.
- Keep the system fast with local caching and incremental updates.

## Phase 1: Data Pipeline (CVE Intelligence Store)

**Outcome:** Local CVE intelligence store with scheduled refresh.

**Sources**
- NVD JSON feeds (primary).
- MITRE CVE list (metadata).
- Optional: OSV or vendor advisories for ecosystem-specific coverage.

**Suggested modules**
- `internal/cve/source` - fetchers for NVD/MITRE/OSV.
- `internal/cve/store` - local persistence and query.
- `internal/cve/sync` - scheduler + incremental updates.

**Suggested store layout**
- Location: `~/.vectra-guard/cve/`
- Data: JSONL or SQLite for fast query.
- Indexes by `package`, `ecosystem`, `version_range`, `cvss`.

**Minimal data model**
```
type CVERecord struct {
  ID            string
  Summary       string
  Severity      string
  CVSS          float64
  PublishedAt   time.Time
  UpdatedAt     time.Time
  Ecosystem     string   // npm, pypi, cargo, gomod, osv, etc.
  Package       string
  VersionRanges []string // semver or ecosystem-specific ranges
  References    []string
}
```

## Phase 2: Dependency Scanner (Manifest + Lockfiles)

**Outcome:** Identify vulnerable packages in dependency manifests.

**Targets**
- `package.json`, `package-lock.json`, `pnpm-lock.yaml`, `yarn.lock`
- `go.mod`, `go.sum`
- `requirements.txt`, `poetry.lock`, `Pipfile.lock`
- `Cargo.toml`, `Cargo.lock`

**Suggested modules**
- `internal/cve/scanner` - manifest parsers and dependency graph.
- `internal/cve/resolve` - version normalization and range checks.

**Behavior**
- Map detected deps to `CVERecord` matches.
- Flag direct and transitive dependencies separately.
- Cache scan results keyed by manifest hash.

## Phase 3: Risk Engine Extension

**Outcome:** Merge CVE risk into existing risk analysis.

**Integration points**
- `internal/analyzer` - add CVE risk signals.
- `internal/sandbox` - enforce block thresholds on install commands.

**Policy ideas**
- Block above `severity_block_threshold` (e.g. high/critical).
- Warn on medium; log on low.
- Prefer newest patched version recommendation when available.

## Phase 4: Interactive Reporting (CLI UX)

**Outcome:** CLI reports CVE findings during `exec` and on-demand scans.

**New commands**
- `vectra-guard cve sync` - fetch/update CVE database.
- `vectra-guard cve scan` - scan current repo manifests.
- `vectra-guard cve explain <pkg>` - show advisory details.

**Exec flow (example)**
```
vg exec -- npm install express-validator

âš  Security Advisory: express-validator@X.Y.Z
- CVE-2025-xxxx (CVSS 8.5): XSS vulnerability
- Exploit potential: Moderate
Recommend upgrading to A.B.C or using an alternative
Blocked due to high risk
```

## Phase 5: Agent Feedback Loop

**Outcome:** Agents consult CVE data before actions.

**Integration ideas**
- Add CVE awareness to agent seed templates (`internal/seed/templates`).
- Provide a `--cve-aware` flag for `vg exec` and `vg validate`.
- Record CVE findings in session audit logs.

## Config Extensions (Proposed)

```
cve:
  enabled: true
  sources: ["nvd", "mitre", "osv"]
  update_interval_hours: 24
  severity_block_threshold: "high"
  allow_transitive_only: false
  cache_dir: "~/.vectra-guard/cve"
```

## Implementation Notes

- Start with read-only CVE sync + scan for a single ecosystem (npm).
- Add fast path for frequent commands using cached scan results.
- Keep source fetchers isolated so providers can be swapped or disabled.
- Ensure offline mode works using last known CVE data.
